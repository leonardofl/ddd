\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[top=3cm,left=3cm,right=2cm,bottom=2cm]{geometry} % para as margens
\usepackage{graphicx} 
\usepackage{alltt} 
\usepackage[hidelinks]{hyperref} 
\usepackage{xspace}


\newcommand{\citacao}[1]{\emph{``#1''}}
\newcommand{\lgg}{linguagem onipresente\xspace}

\title{Resumo do livro ``Domain-Driven Design''}
\author{Leonardo Leite}

\begin{document}

\maketitle

\textbf{Atenção: } este documento trata-se ainda de uma versão em desenvolvimento.

\section{Introdução}


Este documento é um resumo do livro ``Domain-Driven Design, Atacando as Complexidades no Coração do Software'', escrito por Eric Evans em 2003. Os objetivos deste resumo são:

\begin{itemize}
\item Em primeiro lugar, fazer um exercício de fixação e assimilação de minha leitura do livro.
\item Servir de referência rápida para que eu tente aplicar os conceitos do DDD no desenvolvimento de software.
\item Fornecer a outras pessoas uma ideia rápida sobre o que trata o livro Domain-Driven Design, assim como apresentar alguns de seus principais conceitos.
\end{itemize}

Uma consideração importante ao leitor: embora minha prática do desenvolvimento de software já tenha vários pontos de acordo com o DDD, este resumo foi escrito logo após minha leitura do livro. Ou seja, não se trata de um texto baseado em minha experiência com DDD, mas somente na leitura do livro.

Destaco também que o livro que eu li foi a primeira edição da tradução para o português (2009). Aliás, uma tradução não tão boa. O pior exemplo de tradução que achei foi a tradução de \emph{graphs} (grafos) e \emph{edges} (arestas) respectivamente por gráficos e bordas. Não sei dizer se a tradução em si foi melhorada na segunda edição da tradução (2011).

Minha impressão geral sobre o livro: gostei bastante da mentalidade do autor, bem condizente com princípios da Programação Extrema (XP) e ao mesmo tempo com uma boa dose de pragmatismo. No entanto o livro é um tanto quanto grande e verboso. Embora seja definitivamente um clássico, já é relativamente antigo (2003). Dessa forma, acho que talvez possam existir por aí livros mais resumidos que possam transmitir a essência do DDD sem tantas considerações e mais direto ao ponto considerando o atual estado-da-arte do desenvolvimento de software. Não que o livro tenha deixado de ser atual, mas algumas considerações menores poderiam hoje ser deixadas de lado. Ao mesmo tempo, já surgiram alguns paradigmas modernosos como \emph{micro-serviços}, que são bem relacionados com o tema do livro. Portanto, sua decisão de ler ou não o livro vai depender bastante do quanto você deseja se aprofundar no assunto.

Outra consideração bem interessante é, pra mim, foi bem positivo ter demorado pra ler esse livro. Já tinha ouvido falar do livro há alguns anos, mas somente agora finalmente o priorizei. E isso foi bom porque a experiência recente que eu tive desenvolvendo um sistema com um complicado modelo de domínio me ajudou bastante a ler o livro com melhor proveito. Outros sistemas em que trabalhara antes não tinham um modelo de domínio assim tão complexo. Ler o livro e comparar o que o autor descreve com suas próprias experiências é de grande valor para uma melhor leitura do livro. Dessa forma, dou a ousada sugestão de que se você ainda é um desenvolvedor iniciante leia apenas um livro básico (ou mesmo esse resumo) sobre o assunto e espere alguns anos até ler o livro Domain-Driven Design.

\citacao{A principal finalidade de um software é servir aos usuários. Mas, primeiro, esse mesmo software tem que servir aos desenvolvedores}.

Antes de chegar ao que interessa, mais uma consideração. A abordagem de DDD, tal como apresentada no livro, é intimamente ligada à orientação a objetos (OO). Caso você ainda não domine a OO em profundamente, não se preocupe, estudar DDD é até uma boa maneira de reforçar o aprendizado em OO. Mas um alerta se faz necessário. Muitas pessoas ainda vendem a ideia de que o foco principal da OO consiste no mapeamento de entidades do mundo real para o código e a utilização de encapsulamento, herança e polimorfismo. Embora todas essas coisas estejam inclusas na OO, é mais útil considerar que o foco do OO é a decomposição do código de um sistema em unidades coesas e fracamente acopladas. Essas unidade são tanto as pequena unidades (classes), quanto as grandes unidades (pacotes). Uma consequência almejada dessa decomposição é que a manutenção do sistema fica facilitada, pois é possível encontrar rapidamente o ponto a ser alterado e a mesma alteração não precisa ser repetida em diversos pontos do código. Um ótimo livro que ajuda a passar essa ideia sobre a OO é o ``Orientação a Objetos e SOLID para Ninjas''~\cite{Aniche2015Ninjas}.

Obs: \citacao{trechos nesta formatação são citações diretas do livro}.

Bom, chega de enrolação. Vamos ao que interessa...

\section{O modelo do domínio de um software}

O \emph{domínio} de um software é o assunto relacionado às atividades desempenhadas pelos usuários desse software. Exemplos de domínios são compra de passagens aéreas, gestão de pessoas, tradução de texto para outras línguas, o processo legislativo, segurança veicular, previsão do tempo etc.

Para desenvolvermos um software que auxilie as atividades humanas em um dado domínio, precisamos de um \emph{modelo} desse domínio que seja útil à criação desse software. \citacao{Cada modelo representa algum aspecto da realidade com uma ideia que seja de interesse. Um modelo é uma simplificação. Ele é uma interpretação da realidade que destaca os aspectos relevantes para resolver o problema que se tem em mãos ignorando os detalhes estranhos}. Ao ignorar seletivamente esses detalhes, modelos nos ajudam a tratar a sobrecarga de volume e complexidade das informações relacionadas ao domínio. 

Diagramas não são o modelo. O modelo é uma abstração que se reflete em diversos artefatos concretos, como requisitos, diagramas, código-fonte e estrutura do banco de dados. Todos esses artefatos devem estar alinhados com o modelo do domínio. Esse alinhamento diz respeito até mesmo às palavras utilizadas na comunicação entre os membros do time (incluindo desenvolvedores, analistas de negócio e cliente).

O modelo do domínio não pode ser facilmente definido antes da construção do software. O processo de desenvolvimento traz um grande aprendizado para a equipe sobre o domínio. Esse aprendizado deve se refletir em evoluções incrementais do modelo ao longo do desenvolvimento. E enquanto o modelo evolui, os demais artefatos (diagramas, código etc.) também devem evoluir para acompanhar a evolução do modelo. 

\section{A linguagem onipresente}

A situação típica é de que o time de desenvolvimento não esteja habituada ao domínio do software a ser construído. Especialistas do domínio possuem jargões que os desenvolvedores não conhecem. Assim surgem complicações na comunicação entre desenvolvedores e especialistas do domínio. Até mesmo entre os próprios desenvolvedores pode haver confusão, pois cada um pode criar um entendimento diferente sobre o domínio em sua cabeça.

Para fortalecer a comunicação dos envolvidos em um projeto de software e garantir a precisão do modelo, Evans defende extensivamente ao longo do livro a utilização de uma \emph{linguagem onipresente}. Essa linguagem onipresente deve ser utilizada na comunicação oral e escrita do time, além de ser utilizada nos diagramas, código-fonte etc. Assim, a \lgg faz a ligação entre a comunicação do time e a implementação do software.

Lacunas na linguagem onipresente evidenciam a falta de um conceito no modelo. Palavras estranhas podem evidenciar imprecisões do modelo ou divergências entre a implementação e os objetivos do negócio. Mudanças na linguagem onipresente são mudanças no modelo. Assim ela deve ser mantida e zelada por todo o time. Especialistas do domínio devem impedir a existência de termos inapropriados para o domínio, enquanto que desenvolvedores devem impedir ambiguidades e inconsistências.

Na comunicação diária, tanto especialistas quando desenvolvedores ainda utilizarão termos fora da linguagem onipresente. Esses termos podem ser, por exemplo, termos técnicos ligados à implementação do software, ou conceitos mais avançados do negócio, não necessários à implementação do software. Tais termos devem ser complementares à linguagem onipresente, e não conflitantes com a linguagem onipresente.

Embora seja rápido e fácil falar sobre a \lgg, ela é uma ideia central ao longo do livro. Em praticamente todos os capítulos, o autor aproveita para reforçar o assunto, aplicando-o nos mais diferentes contextos, seja na produção de código, seja na conversa com os especialistas.


\section{Camadas de um software}

O primeiro passo para um design dirigido pelo domínio é o isolamento da lógica do negócio de outras características que o software deve implementar. Isso é feito com a separação do software em camadas. Assim temos uma camada do domínio que fica desacoplada do restante do sistema. Isso facilita a manutenção, pois podemos criar designs mais coesivos e identificar rapidamente os pontos de mudança no software. Além disso, o isolamento das regras de negócio potencializa o reuso de código, pois a mesma regra de negócio pode ser reaproveitada em um aplicativo móvel ou por um web service, por exemplo.

As camadas podem ser classificadas em interface, aplicativo, domínio e infra.

\begin{description}
\item [Interface:] interage com o usuário, coletando entradas e exibindo saídas. Esse usuário pode ser tanto uma pessoa quanto outro sistema.
\item [Aplicativo:] implementa as funcionalidades disponíveis para o usuário. Essa camada tende a ser bem magra e apenas dirige a camada de domínio para que a funcionalidade seja entregue.
\item [Domínio:] é o coração do sistema, onde estão os conceitos, regras e estado do negócio. É a parte do sistema onde menos os \emph{frameworks} e plataformas podem ajudar. É onde mais a criatividade e as capacidades de análise e design se fazem necessárias. E é nessa camada que o livro Domain-Driven Design é focado.
\item [Infra:] recursos técnicos como persistência, troca de mensagens etc.
\end{description}

\citacao{O princípio essencial é de que qualquer elemento de uma camada depende somente dos outros elementos da mesma camada ou dos elementos das camadas ``abaixo'' dela. A comunicação para cima deve passar por algum tipo de mecanismo indireto}. Ou seja, o importante aqui é que a camada de domínio seja auto-contida e não dependa de nenhuma das outras camadas do software.

A aplicação do princípio da inversão de dependência para possibilitar que a camada de domínio não dependa de outras camadas é descrito nesses dois posts do Uncle Bob: ``The Clean Architecture''\footnote{https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html} e ``A Little Architecture''\footnote{http://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html}. Citando um trechinho: \citacao{A web é um detalhe. O banco é um detalhe. Nós deixamos essas coisas do lado de fora, onde elas não podem trazer muito dano.}

Muitas pessoas exaltam a importância da infra-estrutura na definição de arquitetura de um software. Alguns acham que a escolha do Sistem Gerenciador de Bancos de Dados é a mais importante. Algumas outras se degladiam pela escolha do \emph{framework} de desenvolvimento. Mas o post ``A Little Architecture'' esclarece como essas coisas na realidade importam muto pouco. As regras de negócio tendem a ser mais duradouras que as tecnologias empregadas. E queremos ser capazes de facilmente substitui tecnologias obsoletas se preciso. Entendemos que as regras de negócio são a parte mais valiosa do sistema. Por isso a importância do estudo do DDD, que consiste no aprimoramento de nossa capacidade em escrever a camada do domínio.


\section{Elementos do domínio}

Os elementos do domínio classificados por Evans são: entidades, objetos de valor e serviços.

\begin{description}

\item [Entidades] representam algo com identidade e com uma continuidade rastreável por diferentes estados e até diferentes implementações. A definição de um objeto como esse não está em seus valores, pois objetos diferentes com valores iguais ainda devem ser distinguíveis. A definição da identidade é a principal característica de uma entidade. Um exemplo de entidade é um veículo que deve ser identificável em diferentes partes do sistema como correspondente a um determinado veículo único existente no mundo real. Dois veículos Fox, da Volkswagen, ambos de cor preta e demais características de fábrica idênticas ainda são veículos distintos.

\item [Objetos de valor] descrevem o estado de alguma coisa. Por exemplo, um veículo pode ter uma cor, que é descrita por uma combinação numérica RGB. Dois veículos podem ter cores idênticas, mas não precisamos nos preocupar com que os dois objetos veículos apontem exatamente para o mesmo objeto cor. Ou seja, nesse caso a cor não possui uma identidade. Ela é meramente um valor. Para reforçar: enquanto uma entidade define \emph{quem} ela é, um objeto de valor define \emph{o que} ele é. Objetos de valor devem ser imutáveis. Assim, um veículo pode mudar de cor, mas não é a cor do veículo que se altera. Ou seja, o objeto veículo passa a apontar para um novo objeto cor e o antigo objeto cor é esquecido. A imutabilidade traz várias vantagens ao design de software~\cite{Bloch2008}, e podemos aproveitar essas vantagens nos objetos de valor.

\item [Serviços] acomodam operações que não cabem nas entidades. É preciso ter cuidado, porque existem serviços nas camadas de domínio, infra e aplicativo.
\item [Módulos], também chamados de pacotes (no java), são agrupamentos de classes. Devem possuir significado no domínio, ou seja, a hierarquia de módulos deve refletir uma hierarquia do domínio.
\end{description}

* Separar pacotes por conceitos do domínio, e não pelas camadas técnicas. Ex ruim: entidades, valores, serviços. Ex bom: cliente, cobrança, transporte de cargas.

Pg 107 crítica à separação entity vs BC... modelo anêmico... objects vs data structures

\section{Padrões do ciclo de vida de um objeto do domínio}

\begin{description}
\item [agregados:] possui uma entidade e vários objetos d valor. Membros externos ao agregado acessam a entidade e não podem modificar diretamente os objetos d valor. Entidade garante as invariantes do grupo. Ex: carro vs penu. Ex: laudo vs {proprietario, veiculo vistoriado...}.
\item [fábricas:] A função da fábrica é instanciar um objeto potencialmente complexo a partir dos dados. Fábrica não cuida de persistência. A fábrica pode instanciar um novo objeto ou reconstituir um objeto já existente a partir de seu formato serializado.
\item [repositórios:] faz o CRUD do objeto. Interface do repositório é ligado ao modelo, e não à infra. O repositório usa um DAO para ter acesso a infra. Ou seja, no repositório ficam as regras de negócio de CRUD da entidade, não os mecanismos tecnológicos de persistência. Esses últimos ficam no DAO, que é da camada de infra.
\end{description}

Então um cenário típico de uso, para a criaçaõ de um novo objeto, fica assim:
\begin{enumerate}
\item Cliente pede pra fábrica criar objeto.
\item Cliente pede pra inserir objeto no repositório.
\item Repositório pede pro DAO persitir o objeto.
\end{enumerate}

Já para a reconstituição de um objeto, podemos ter:

\begin{enumerate}
\item Cliente pede objeto para repositório.
\item Repositório acessa o banco via DAO para obter dados persistidos do objeto.
\item Repositório repassa dados persistidos do objeto a fábrica.
\item Fábrica reconsrói objeto, que é devolvido ao repositório, que é devolvido ao cliente para a edição.
\end{enumerate}

A complexidade desses passos decorre do caso mais complicado no qual a reconstituição do objeto não se resume simplesmente a restaurar os dados persistidos no banco. O que é o banco guarda, pode ser apenas parte do que é objeto é em tempo de execução. Esse é um dos motivos pelo qual é muito arriscado permitir que o sistema de uma aplicação tenha acesso direto ao banco de dados de outra aplicação. Por mais que impor algumas restrições no modelo de dados do banco possa ser uma ideia em caráter de garantia extra, essas regras podem não dar conta de manter complexas restrições semânticas decorrentes do domínio.

Detalhe importante: mesmo a interface que o DAO fornece não deve conter detalhes da tecnologia. Assim, tudo o que o domínio sabe é que a entidade está sendo persistida em algum lugar, mas sem nenhuma dependência com alguma tecnologia específica. Alguns programadores leval isso mais a sério ao criar interfaces para os DAOs, fazerem o domínio depender da interface, e aí criar implementações acopladas ao banco, mas que são desconehcidas do domínio. Essa complicação faz sentido, mas eu acredito que esse trabalho possa ser evitado enquanto se mantenha primeira ideia do parágrafo: a interface do DAO (i.e. nome de classe e assinaturas dos métodos) não pode conter detalhes específicos de tecnologia.

\section{Evolução do modelo do domínio}




Refatoração constante.

Evoluções passo a passo são as vezes interrompidas por uma oportunidade de avanço onde as coisas mudam bastante de uma só vez. São as oportunidades de avanço: 

* Busca por um modelo mais profundo.

* Evitar regras de casos particulares.

* As vezes há uma oportunidade de avanço para um modelo mais profundo que requer uma grande refatoração, daquelas que é difícil concluir sem deixar o código quebrado por um tempo. Mas vale a pena.

* Refatoração técnica (melhora o design, mas sem alterar o modelo do domínio) vs refatoração para refinamento do modelo. A primeira é algo mecânico, a segunda é mais subjetiva.

O autor enfatiza o como sessões em que desenvolvedores e analistas de negócios se juntam para rabiscar diagramas pode ser proveitosa (para evoluir o modelo). Nessa toada, uma coisa que o autor valoriza são os diagramas informais. Se prender às normas restritas da UML pode não ser o ideal para passar uma certa mensagem. Afinal, um bom diagrama é sobre comunicar sucintamente algo à equipe. Do meu ponto de vista, acho aborrecedor com as diversas ferramentas UML por aí que inserem restrições diversas (ex: homens palitos só podem ser inseridos em diagramas de caso de uso).

\section{Outras dicas de design}

* Associações bidirecionais (e referências circulares) são problemáticas para o design (mas as vezes necessárias).

* A direção da travessia muitas vezes capta uma visão aprofundada do domínio, aprofundando o próprio modelo. 

* Explicite os conceitos implícitos.

* É preciso muita iteração e conversa com os especialistas do domínio. Rabiscar diagramas no quadro branco ajuda bastante. 

* Acertar o design de primeira não existe.

* Ler livros sobre o domínio pode ajudar também.

* Outros conceitos além de substantivos/verbos para fazerem parte do modelo: restrições, processos de negócios e especificações.

Uso de especificações...

* Interface reveladora de intenções. Diminuir esforço cognitivo do desenvolvedor. Se a mente do desenvolvedor está transbordando de detalhes internos sobre o objeto utilizado, sua mente não está limpa para resolver o problema. Se é preciso considerar a implementação de um componente para utilizá-lo, o valor do encapsulamento é perdido. Utilizar bons nomes é um caminho para resolver esses problemas. TDD (testes de unidade antes da implementação) também ajuda.

* Funções (devolvem valores) vs comandos (têm efeitos colaterais). Um método deve ser ou uma função ou um comando, não misture os dois. Prefira funções. Comandos devem ser bem simples. Cálculos complexos ficam melhor em objetos de valor (não em entidades).

* Se esforce para reduzir as dependência entre classes e módulos (diminuir o acoplamento). Se possível, crie classes autônomas, que podem ser estudadas por si só. Isso diminui o esforço cognitivo em compreender/usar/testar os elementos do domínio. Obs: dependências visíveis na interface são piores que dependências internas; dependências com elementos fora do módulo são piores que dependência com elementos dentro do módulo.

* Se possível, crie operação *fechadas* sobre elas mesmas. Ou seja, a operação retorna um objeto do mesmo tipo que o objeto que contém a operação (x.inverse()). Também ajuda: retorno do mesmo tipo que o argumento.

* O autor vê com certa reserva abordagens como design declarativos, sistemas baseados em regras e linguagens declarativas. São interessantes, mas há limitações. O autor encoraja a utilização dos padrões apresentados ao longo do capítulo para que o código de objetos tenha um estilo mais declarativo. Essa discussão é bem parecido com a questão se fazer BDD com ou sem a linguagem de alto nível, mais próxima da linguagem natural.

* Como estilo declarativo o autor dá alguns exemplos de combinações de especificações usando operadores lógicos. Assim chegamos a códigos como "Spec both = ventilated.and(armored)", onde ventilated e armored são Spec. No geral, creio que padrões de "linguagens fluentes" ajudem nesse propósito. Em geral esses padrões são construídos que retornam o próprio objeto invocado (ex: design pattern Builder). Pode-se até chegar ao ponto de verificar se uma spec contém outra spec: manSpec.inclui(mortalSpec).

Depois de uma discussão sobre alterar o modelo, pode ser legal esperar alguns dias pra discutir novamente, com a ideia mais madura, antes de de fato por a mão na massa e alterar o design ("dormir com o problema" ajuda).

Refatore quando:
* O design não expressa o entendimento atual da equipe sobre o domínio.
* Conceitos importantes estão implícitos no design.
* Você vê uma oportunidade de tornar mais flexível alguma parte importante do design.

Design e emergência... citar caindo na real.

\section{Arquitetura de larga escala}

Os capítulos finais do livro (cap 14 em diante) apresentam algumas ideias interessantes sobre como lidar com grandes sistemas de software, nos quais fica difícil manter um único modelo de domínio para todas as funcionalidades. Um caso particular bastante abordado pelo o autor é a integração com sistemas legados.

Embora tais técnicas sejam interessantes, não são tão essenciais quanto o início do livro, pois se trata de técnicas que não se aplicam a todos os projetos. Por isso, dependendo da sua situação (experiência e tipos de projeto com o qual trabalha), pode ser uma opção interessante em um primeiro momento ler o livro apenas até o capítulo 13. Mas vou dar aqui uma breve explanada sobre essas ideias finais do livro.

\section{Objetos não são estruturas de dados}

Minha primeira impressão sobre DDD é de que se trata de evitar os chamadas modelos anêmicos, nos quais o modelo são basicamente estruturas de dados persistidas no banco. Tem um post do blog da Caelumn que fala sobre isso\footnote{\url{http://blog.caelum.com.br/o-que-e-modelo-anemico-e-por-que-fugir-dele/}}. Mas para mim só essa visão era difícil de aceitar, por causa do capítulo 6 ``Objects and Data Structures'' do livro Clean Code~\cite{Bob2008Clean}. Nesse capítulo o autor argumenta que as estruturas de dados tem seu lugar e que não se faz um programa 100\% OO. O importante seria não misturar as coisas. Então, pensando no princípio da responsabilidade única, no qual já tenho uma estrutura de dados com as informações de uma entidade, e que essa estrutura tem como responsabilidade principal ser algo a ser persistido no banco, parece talvez incorreto acrescentar comportamentos a essa classe. Eu escrevi um post mais detalhado sobre essa questão no blog do PoliGNU\footnote{\url{http://polignu.org/artigo/clean-code-objetos-n\%C3\%A3o-s\%C3\%A3o-estruturas-de-dados}}.

Outra questão que me deixa em dúvida é como o padrão active record entra nessa história...


\bibliographystyle{apalike}
\bibliography{referencias}  


\end{document}
