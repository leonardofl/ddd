\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[top=3cm,left=3cm,right=2cm,bottom=2cm]{geometry} % para as margens
\usepackage{graphicx} 
\usepackage{alltt} 
\usepackage[hidelinks]{hyperref} 


\newcommand{\citacao}[1]{\emph{``#1''}}

\title{Resumo do livro ``Domain-Driven Design''}
\author{Leonardo Leite}

\begin{document}

\maketitle

\textbf{Atenção: } este documento trata-se ainda de uma versão em desenvolvimento.

\section{Introdução}


Este documento é um resumo do livro ``Domain-Driven Design, Atacando as Complexidades no Coração do Software'', escrito por Eric Evans em 2003. Os objetivos deste resumo são:

\begin{itemize}
\item Em primeiro lugar, fazer um exercício de fixação e assimilação de minha leitura do livro.
\item Servir de referência rápida para que eu tente aplicar os conceitos do DDD no desenvolvimento de software.
\item Fornecer a outras pessoas uma ideia rápida sobre o que trata o livro Domain-Driven Design, assim como apresentar alguns de seus principais conceitos.
\end{itemize}

Uma consideração importante ao leitor: embora minha prática do desenvolvimento de software já tenha vários pontos de acordo com o DDD, este resumo foi escrito logo após minha leitura do livro. Ou seja, não se trata de um texto baseado em minha experiência com DDD, mas somente na leitura do livro.

Destaco também que o livro que eu li foi a primeira edição da tradução para o português (2009). Aliás, uma tradução não tão boa. O pior exemplo de tradução que achei foi a tradução de \emph{graphs} (grafos) e \emph{edges} (arestas) respectivamente por gráficos e bordas. Não sei dizer se a tradução em si foi melhorada na segunda edição da tradução (2011).

Minha impressão geral sobre o livro: gostei bastante da mentalidade do autor, bem condizente com princípios da Programação Extrema (XP) e ao mesmo tempo com uma boa dose de pragmatismo. No entanto o livro é um tanto quanto grande e verboso. Embora seja definitivamente um clássico, já é relativamente antigo (2003). Dessa forma, acho que talvez possam existir por aí livros mais resumidos que possam transmitir a essência do DDD sem tantas considerações e mais direto ao ponto considerando o atual estado-da-arte do desenvolvimento de software. Não que o livro tenha deixado de ser atual, mas algumas considerações menores poderiam hoje ser deixadas de lado. Ao mesmo tempo, já surgiram alguns paradigmas modernosos como \emph{micro-serviços}, que são bem relacionados com o tema do livro. Portanto, sua decisão de ler ou não o livro vai depender bastante do quanto você deseja se aprofundar no assunto.

Outra consideração bem interessante é, pra mim, foi bem positivo ter demorado pra ler esse livro. Já tinha ouvido falar do livro há alguns anos, mas somente agora finalmente o priorizei. E isso foi bom porque a experiência recente que eu tive desenvolvendo um sistema com um complicado modelo de domínio me ajudou bastante a ler o livro com melhor proveito. Outros sistemas em que trabalhara antes não tinham um modelo de domínio assim tão complexo. Ler o livro e comparar o que o autor descreve com suas próprias experiências é de grande valor para uma melhor leitura do livro. Dessa forma, dou a ousada sugestão de que se você ainda é um desenvolvedor iniciante leia apenas um livro básico (ou mesmo esse resumo) sobre o assunto e espere alguns anos até ler o livro Domain-Driven Design.

\citacao{A principal finalidade de um software é servir aos usuários. Mas, primeiro, esse mesmo software tem que servir aos desenvolvedores}.

Antes de chegar ao que interessa, mais uma consideração. A abordagem de DDD, tal como apresentada no livro, é intimamente ligada à orientação a objetos (OO). Caso você ainda não domine a OO em profundamente, não se preocupe, estudar DDD é até uma boa maneira de reforçar o aprendizado em OO. Mas um alerta se faz necessário. Muitas pessoas ainda vendem a ideia de que o foco principal da OO consiste no mapeamento de entidades do mundo real para o código e a utilização de encapsulamento, herança e polimorfismo. Embora todas essas coisas estejam inclusas na OO, é mais útil considerar que o foco do OO é a decomposição do código de um sistema em unidades coesas e fracamente acopladas. Essas unidade são tanto as pequena unidades (classes), quanto as grandes unidades (pacotes). Uma consequência almejada dessa decomposição é que a manutenção do sistema fica facilitada, pois é possível encontrar rapidamente o ponto a ser alterado e a mesma alteração não precisa ser repetida em diversos pontos do código. Um ótimo livro que ajuda a passar essa ideia sobre a OO é o ``Orientação a Objetos e SOLID para Ninjas''~\cite{Aniche2015Ninjas}.

Obs: \citacao{trechos nesta formatação são citações diretas do livro}.

Bom, chega de enrolação. Vamos ao que interessa...

\section{O modelo do domínio de um software}

O \emph{domínio} de um software é o assunto relacionado às atividades desempenhadas pelos usuários desse software. Exemplos de domínios são compra de passagens aéreas, gestão de pessoas, tradução de texto para outras línguas, o processo legislativo, segurança veicular, previsão do tempo etc.

Para desenvolvermos um software que auxilie atividades humanas em um dado domínio, precisamos de um \emph{modelo} desse domínio que seja útil à criação desse software. \citacao{Cada modelo representa algum aspecto da realidade com uma ideia que seja de interesse. Um modelo é uma simplificação. Ele é uma interpretação da realidade que destaca os aspectos relevantes para resolver o problema que se tem em mãos ignorando os detalhes estranhos}. Ao ignorar seletivamente esses detalhes, modelos nos ajudam a tratar a sobrecarga de volume e complexidade das informações relacionadas ao domínio. 

Diagramas não são o modelo. O modelo é uma abstração que se reflete em diversos artefatos concretos, como requisitos, diagramas, código-fonte e estrutura do banco de dados. Todos esses artefatos devem estar alinhados com o modelo do domínio. Esse alinhamento diz respeito até mesmo às palavras utilizadas na comunicação entre os membros do time (incluindo desenvolvedores, analistas de negócio e cliente).

O modelo do domínio não pode ser facilmente definido antes da construção do software, pois o processo de desenvolvimento traz um grande aprendizado para equipe sobre o domínio. Esse aprendizado deve se refletir em evoluções incrementais do modelo ao longo do desenvolvimento. E enquanto o modelo evolui, assim os diagramas, código e demais artefatos também evoluem para acompanhar a evolução do modelo. 

\section{A linguagem onipresente}

Evans defende extensivamente ao longo do livro a utilização de uma \emph{linguagem onipresente} para falar do modelo e para se aplicar nos artefatos concretos. Assim, ocorre uma melhor assimilação dos desenvolvedores sobre o que dizem os especilistas dos negócios. Assim, fica evidente desvios que a arquitetura esteja tomando em relação ao negócio. A utilização de uma linguagem onipresente é uma ferramenta realmente poderosa.

Um dos lugares em que a linguagem onipresente deve estar presente são os diagramas do sistema. O autor enfatiza o como sessões em que desenvolvedores e analistas de negócios se juntam para rabiscar diagramas pode ser proveitosa. Nessa toada, uma coisa que o autor valoriza são os diagramas informais. Se prender às normas restritas da UML pode não ser o ideal para passar uma certa mensagem. Afinal, um bom diagrama é sobre comunicar sucintamente algo à equipe. Do meu ponto de vista, acho aborrecedor com as diversas ferramentas UML por aí que inserem restrições diversas (ex: homens palitos só podem ser inseridos em diagramas de caso de uso).

Então falar rapidamente da linguagem onipresente parece diminuir a importância dela. Falo rapidamente porque a ideia é simples. Mas cabe destacar que é a ideia mais importante do livro. Em todo capítulo o autor aproveita para reforçar o assunto, aplicando-o nos mais diferentes contextos, seja na produção de código, seja na conversa com so especialistas.


\section{Camadas de um software}

As camadas de um software geralmente se resumem a interface, aplicativo, domínio e infra.

\begin{description}
\item [Interface:]
\item [Aplicativo:] não contém regras de negócio. Tende a ser bem magra. Essa camada utiliza a camada do domínio.
\item [Domínio:] é o coração do sistema, onde estão as regras do negócio. É a parte do sistema onde menos os \emph{frameworks} e plataformas podem ajudar. É onde mais a criatividade e as capacidades de análise e design se fazem necessárias. E é nessa camada que o livro Domain-Driven Design é focado.
\item [Infra:] ecursos técnicos como mensagens, persistência etc.
\end{description}

Muitas pessoas exaltam muito a importância da infra-estrutura na definição de arquitetura de um software. Alguns acham que a escolha do Sistem Gerenciador de Bancos de Dados é a mais importante. Algumas outras se degladiam pela escolha do \emph{framework} de desenvolvimento. Mas o Uncle Bob é bem feliz ao explicar como essas coisas na realidade importam muto pouco\footnote{http://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html}. Assim, entendemos que o núcleo do sistema é composto pelas regras de negócio. Essas regras tendem a ser mais duradouras que as tecnologias empregadas. E são essas regras que, no fim, das contas, entregam valor ao negócio. Por isso a importância do estudo do DDD, que consiste no aprimoramento de nossa capacidade em melhor desenvolver essa cadama do domínio.

Uncle bob também esclare como a camada de domínio não deve depender da camada de infra. O negócio não pode depender da tecnologia. Isso fica evidente na apresentação da arquitetura hexagonal\footnote{https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html}.

\section{Elementos do domínio}

Os elementos do domínio classificados por Evans são: entidades, objetos de valor e serviços.

\begin{description}
\item [Entidades] são identificáveis e possuem um ciclo de vida. 
\item [Objetos de valor] são intercambiáveis (não possuem identidade) e devem ser imutáveis.
\item [Serviços] acomodam operações que não cabem nas entidades. É preciso ter cuidado, porque existem serviços nas camadas de domínio, infra e aplicativo.
\item [Módulos], também chamados de pacotes (no java), são agrupamentos de classes. Devem possuir significado no domínio, ou seja, a hierarquia de módulos deve refletir uma hierarquia do domínio.
\end{description}

* Separar pacotes por conceitos do domínio, e não pelas camadas técnicas. Ex ruim: entidades, valores, serviços. Ex bom: cliente, cobrança, transporte de cargas.

Pg 107 crítica à separação entity vs BC... modelo anêmico... objects vs data structures

\section{Padrões do ciclo de vida de um objeto do domínio}

\begin{description}
\item [agregados:] possui uma entidade e vários objetos d valor. Membros externos ao agregado acessam a entidade e não podem modificar diretamente os objetos d valor. Entidade garante as invariantes do grupo. Ex: carro vs penu. Ex: laudo vs {proprietario, veiculo vistoriado...}.
\item [fábricas:] A função da fábrica é instanciar um objeto potencialmente complexo a partir dos dados. Fábrica não cuida de persistência. A fábrica pode instanciar um novo objeto ou reconstituir um objeto já existente a partir de seu formato serializado.
\item [repositórios:] faz o CRUD do objeto. Interface do repositório é ligado ao modelo, e não à infra. O repositório usa um DAO para ter acesso a infra. Ou seja, no repositório ficam as regras de negócio de CRUD da entidade, não os mecanismos tecnológicos de persistência. Esses últimos ficam no DAO, que é da camada de infra.
\end{description}

Então um cenário típico de uso, para a criaçaõ de um novo objeto, fica assim:
\begin{enumerate}
\item Cliente pede pra fábrica criar objeto.
\item Cliente pede pra inserir objeto no repositório.
\item Repositório pede pro DAO persitir o objeto.
\end{enumerate}

Já para a reconstituição de um objeto, podemos ter:

\begin{enumerate}
\item Cliente pede objeto para repositório.
\item Repositório acessa o banco via DAO para obter dados persistidos do objeto.
\item Repositório repassa dados persistidos do objeto a fábrica.
\item Fábrica reconsrói objeto, que é devolvido ao repositório, que é devolvido ao cliente para a edição.
\end{enumerate}

A complexidade desses passos decorre do caso mais complicado no qual a reconstituição do objeto não se resume simplesmente a restaurar os dados persistidos no banco. O que é o banco guarda, pode ser apenas parte do que é objeto é em tempo de execução. Esse é um dos motivos pelo qual é muito arriscado permitir que o sistema de uma aplicação tenha acesso direto ao banco de dados de outra aplicação. Por mais que impor algumas restrições no modelo de dados do banco possa ser uma ideia em caráter de garantia extra, essas regras podem não dar conta de manter complexas restrições semânticas decorrentes do domínio.

Detalhe importante: mesmo a interface que o DAO fornece não deve conter detalhes da tecnologia. Assim, tudo o que o domínio sabe é que a entidade está sendo persistida em algum lugar, mas sem nenhuma dependência com alguma tecnologia específica. Alguns programadores leval isso mais a sério ao criar interfaces para os DAOs, fazerem o domínio depender da interface, e aí criar implementações acopladas ao banco, mas que são desconehcidas do domínio. Essa complicação faz sentido, mas eu acredito que esse trabalho possa ser evitado enquanto se mantenha primeira ideia do parágrafo: a interface do DAO (i.e. nome de classe e assinaturas dos métodos) não pode conter detalhes específicos de tecnologia.

\section{Evolução do modelo do domínio}

Refatoração constante.

Evoluções passo a passo são as vezes interrompidas por uma oportunidade de avanço onde as coisas mudam bastante de uma só vez. São as oportunidades de avanço: 

* Busca por um modelo mais profundo.

* Evitar regras de casos particulares.

* As vezes há uma oportunidade de avanço para um modelo mais profundo que requer uma grande refatoração, daquelas que é difícil concluir sem deixar o código quebrado por um tempo. Mas vale a pena.

* Refatoração técnica (melhora o design, mas sem alterar o modelo do domínio) vs refatoração para refinamento do modelo. A primeira é algo mecânico, a segunda é mais subjetiva.



\section{Outras dicas de design}

* Associações bidirecionais (e referências circulares) são problemáticas para o design (mas as vezes necessárias).

* A direção da travessia muitas vezes capta uma visão aprofundada do domínio, aprofundando o próprio modelo. 

* Explicite os conceitos implícitos.

* É preciso muita iteração e conversa com os especialistas do domínio. Rabiscar diagramas no quadro branco ajuda bastante. 

* Acertar o design de primeira não existe.

* Ler livros sobre o domínio pode ajudar também.

* Outros conceitos além de substantivos/verbos para fazerem parte do modelo: restrições, processos de negócios e especificações.

Uso de especificações...

* Interface reveladora de intenções. Diminuir esforço cognitivo do desenvolvedor. Se a mente do desenvolvedor está transbordando de detalhes internos sobre o objeto utilizado, sua mente não está limpa para resolver o problema. Se é preciso considerar a implementação de um componente para utilizá-lo, o valor do encapsulamento é perdido. Utilizar bons nomes é um caminho para resolver esses problemas. TDD (testes de unidade antes da implementação) também ajuda.

* Funções (devolvem valores) vs comandos (têm efeitos colaterais). Um método deve ser ou uma função ou um comando, não misture os dois. Prefira funções. Comandos devem ser bem simples. Cálculos complexos ficam melhor em objetos de valor (não em entidades).

* Se esforce para reduzir as dependência entre classes e módulos (diminuir o acoplamento). Se possível, crie classes autônomas, que podem ser estudadas por si só. Isso diminui o esforço cognitivo em compreender/usar/testar os elementos do domínio. Obs: dependências visíveis na interface são piores que dependências internas; dependências com elementos fora do módulo são piores que dependência com elementos dentro do módulo.

* Se possível, crie operação *fechadas* sobre elas mesmas. Ou seja, a operação retorna um objeto do mesmo tipo que o objeto que contém a operação (x.inverse()). Também ajuda: retorno do mesmo tipo que o argumento.

* O autor vê com certa reserva abordagens como design declarativos, sistemas baseados em regras e linguagens declarativas. São interessantes, mas há limitações. O autor encoraja a utilização dos padrões apresentados ao longo do capítulo para que o código de objetos tenha um estilo mais declarativo. Essa discussão é bem parecido com a questão se fazer BDD com ou sem a linguagem de alto nível, mais próxima da linguagem natural.

* Como estilo declarativo o autor dá alguns exemplos de combinações de especificações usando operadores lógicos. Assim chegamos a códigos como "Spec both = ventilated.and(armored)", onde ventilated e armored são Spec. No geral, creio que padrões de "linguagens fluentes" ajudem nesse propósito. Em geral esses padrões são construídos que retornam o próprio objeto invocado (ex: design pattern Builder). Pode-se até chegar ao ponto de verificar se uma spec contém outra spec: manSpec.inclui(mortalSpec).

Depois de uma discussão sobre alterar o modelo, pode ser legal esperar alguns dias pra discutir novamente, com a ideia mais madura, antes de de fato por a mão na massa e alterar o design ("dormir com o problema" ajuda).

Refatore quando:
* O design não expressa o entendimento atual da equipe sobre o domínio.
* Conceitos importantes estão implícitos no design.
* Você vê uma oportunidade de tornar mais flexível alguma parte importante do design.

Design e emergência... citar caindo na real.

\section{Arquitetura de larga escala}

Os capítulos finais do livro (cap 14 em diante) apresentam algumas ideias interessantes sobre como lidar com grandes sistemas de software, nos quais fica difícil manter um único modelo de domínio para todas as funcionalidades. Um caso particular bastante abordado pelo o autor é a integração com sistemas legados.

Embora tais técnicas sejam interessantes, não são tão essenciais quanto o início do livro, pois se trata de técnicas que não se aplicam a todos os projetos. Por isso, dependendo da sua situação (experiência e tipos de projeto com o qual trabalha), pode ser uma opção interessante em um primeiro momento ler o livro apenas até o capítulo 13. Mas vou dar aqui uma breve explanada sobre essas ideias finais do livro.

\section{Objetos não são estruturas de dados}

Minha primeira impressão sobre DDD é de que se trata de evitar os chamadas modelos anêmicos, nos quais o modelo são basicamente estruturas de dados persistidas no banco. Tem um post do blog da Caelumn que fala sobre isso\footnote{\url{http://blog.caelum.com.br/o-que-e-modelo-anemico-e-por-que-fugir-dele/}}. Mas para mim só essa visão era difícil de aceitar, por causa do capítulo 6 ``Objects and Data Structures'' do livro Clean Code~\cite{Bob2008Clean}. Nesse capítulo o autor argumenta que as estruturas de dados tem seu lugar e que não se faz um programa 100\% OO. O importante seria não misturar as coisas. Então, pensando no princípio da responsabilidade única, no qual já tenho uma estrutura de dados com as informações de uma entidade, e que essa estrutura tem como responsabilidade principal ser algo a ser persistido no banco, parece talvez incorreto acrescentar comportamentos a essa classe. Eu escrevi um post mais detalhado sobre essa questão no blog do PoliGNU\footnote{\url{http://polignu.org/artigo/clean-code-objetos-n\%C3\%A3o-s\%C3\%A3o-estruturas-de-dados}}.

Outra questão que me deixa em dúvida é como o padrão active record entra nessa história...


\bibliographystyle{plain}
\bibliography{referencias}  


\end{document}
