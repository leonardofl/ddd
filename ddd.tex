\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[top=3cm,left=3cm,right=2cm,bottom=2cm]{geometry} % para as margens
\usepackage{graphicx} 
\usepackage{alltt} 
%\usepackage[hidelinks]{hyperref} 
\usepackage{hyperref} 
\usepackage{xspace}
\usepackage{listings}

\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}

\hyphenation{booleano}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\citacao}[1]{\emph{``#1''}}
\newcommand{\lgg}{linguagem onipresente\xspace}
\newcommand{\ddd}{\emph{Domain Driven Design}\xspace}

\title{Notas sobre o livro Domain-Driven Design}
\author{Leonardo Leite \\ {\footnotesize \url{http://www.ime.usp.br/~leofl/}}}

\begin{document}

\maketitle

\citacao{A principal finalidade de um software é servir aos usuários. Mas, primeiro, esse mesmo software tem que servir aos desenvolvedores}.

\section{Introdução}

Este documento é um compilado de notas de leitura sobre o livro ``\ddd: Atacando as Complexidades no Coração do Software''~\cite{Evans2003DDD}. O DDD, design dirigido pelo domínio, é uma abordagem de desenvolvimento de software voltado para domínios complexos. No DDD, o software possui uma camada baseada em um modelo rico do domínio, sendo essa camada isolada dos aspectos mais técnicos do sistema. Conjuntamente com os princípios SOLID\footnote{\url{https://en.wikipedia.org/wiki/SOLID_\%28object-oriented_design\%29}}, padrões de projetos, escrita de código limpo e desenvolvimento dirigido por testes, considero o DDD uma das grande práticas para que o desenvolvedor faça um uso mais correto e proveitoso do paradigma de orientação a objetos. Os objetivos deste documento são:

\begin{itemize}
\item Ser um exercício pessoal de fixação e assimilação de minha leitura do livro.
\item Ser uma referência rápida sobre DDD conforma a visão de Eric Evans.
\item Fornecer uma visão geral sobre o livro \ddd para outras pessoas.
\end{itemize}

Este texto foi escrito logo após minha leitura do livro. Logo, o texto não se baseia em minha experiência pessoal aplicando o DDD na prática. A grande maioria das afirmativas deste texto são baseados no livro sobre DDD de Eric Evans. Contudo, faz também parte do texto algumas afirmativas baseadas em minha experiência pessoal como desenvolvedor de software. Como esse não é um texto acadêmico, não priorizei separar claramente minhas afirmativas das afirmativas do livro, para não quebrar a fluidez do texto. Contudo, \citacao{textos entre aspas nesta formatação são citações diretas do livro, a menos que outra fonte esteja sendo citada}. A motivação para a citação de outas fontes é mais para servir de sugestão de boas leituras do que para justificar as afirmativas do texto. Conceitos chaves do livro de Evans estão em \emph{itálico}.

A edição do livro que utilizei foi a primeira edição da tradução para o português (2009). Aliás, uma tradução não tão boa. O pior exemplo de tradução que achei foi a tradução de \emph{graphs} (grafos) e \emph{edges} (arestas) respectivamente por gráficos e bordas. Não sei dizer se a tradução em si foi melhorada na segunda edição da tradução (2011). Na dúvida, sugiro a leitura do original em inglês.

O livro de Evans é um clássico da literatura sobre desenvolvimento de software, endossado por grandes nomes como Martin Fowler. Evans apresenta ao longo do livro uma mentalidade alinhada com os princípios da Programação Extrema (XP) e ao mesmo tempo uma boa dose de pragmatismo. No entanto, o livro é um tanto grande e verboso. O livro já é também relativamente antigo (2003), o que inclui no livro algumas considerações hoje já não tão importantes, enquanto deixa de fora alguns tópicos atuais relacionados ao tema do livro, como \emph{micro-serviços}\footnote{\url{http://martinfowler.com/articles/microservices.html}}. Dito isso, você pode querer considerar ler outros livros sobre DDD que não o clássico original sobre o qual escrevo.

Já fazia alguns anos que eu queria ler esse livro. Mas essa demora em ler o livro foi positiva. Atualmente trabalho como desenvolvedor de software do governo federal, e modelos de domínios da área governamental costumam ser bem complexos. Dessa forma, minha experiência recente me deu mais embasamento para melhor aproveitar a leitura do livro. Tentar contextualizar os conceitos e exemplos do livro em sua experiência é um exercício muito valioso. Dessa forma, dou a ousada sugestão de que se você ainda é um desenvolvedor iniciante leia por ora apenas um livro básico sobre DDD (ou mesmo este resumo ;) e espere alguns anos até ler o clássico \ddd.

A abordagem de DDD é intimamente ligada à orientação a objetos (OO). Caso você ainda não domine a OO em profundamente, não pare aqui por causa disso. Estudar DDD é uma boa maneira de ampliar seu entendimento sobre a OO. Mas um alerta se faz necessário. Muitas pessoas entendem que o foco principal da OO consiste no mapeamento de entidades do mundo real para o código e a utilização de encapsulamento, herança e polimorfismo. Embora todas essas coisas estejam inclusas na OO, é mais útil considerar que o foco da OO é a decomposição de um sistema em unidades coesas e fracamente acopladas. Essas unidades são tanto as pequena unidades (classes), quanto as grandes unidades (pacotes). Um objetivo dessa decomposição é facilitar a manutenção do sistema. Dada uma demanda evolutiva, usando bem a OO é possível encontrar rapidamente o ponto do código a ser alterado. Além disso, essa mesma alteração não precisa ser repetida em diversos pontos do código. Um ótimo livro que ajuda a passar essa visão mais avançada sobre a OO é o ``Orientação a Objetos e SOLID para Ninjas''~\cite{Aniche2015Ninjas}.

\section{O modelo do domínio de um software}

O \emph{domínio} de um software é o assunto relacionado às atividades desempenhadas pelos usuários desse software. Exemplos de domínios são compra de passagens aéreas, gestão de pessoas, tradução de texto para outras línguas, o processo legislativo, segurança veicular, previsão do tempo etc.

Para desenvolvermos um software que auxilie as atividades humanas em um dado domínio, precisamos de um \emph{modelo} desse domínio que seja útil à criação desse software. \citacao{Cada modelo representa algum aspecto da realidade com uma ideia que seja de interesse. Um modelo é uma simplificação. Ele é uma interpretação da realidade que destaca os aspectos relevantes para resolver o problema que se tem em mãos ignorando os detalhes estranhos}. Ao ignorar seletivamente esses detalhes, modelos nos ajudam a tratar a sobrecarga de volume e complexidade das informações relacionadas ao domínio. 

Diagramas não são o modelo. O modelo é uma abstração que se reflete em diversos artefatos concretos, como requisitos, diagramas, código-fonte e estrutura do banco de dados. Todos esses artefatos devem estar alinhados com o modelo do domínio. Esse alinhamento diz respeito até mesmo às palavras utilizadas na comunicação entre os membros do time (incluindo desenvolvedores, analistas de negócio e cliente).

O modelo do domínio não pode ser facilmente definido antes da construção do software. O processo de desenvolvimento traz um grande aprendizado para a equipe sobre o domínio. Esse aprendizado deve se refletir em evoluções incrementais do modelo ao longo do desenvolvimento. E enquanto o modelo evolui, os demais artefatos (diagramas, código etc.) também devem evoluir para acompanhar a evolução do modelo. 

\section{A linguagem onipresente}

A situação típica é de que o time de desenvolvimento não esteja habituado ao domínio do software a ser construído. Especialistas do domínio possuem jargões que os desenvolvedores não conhecem. Assim surgem complicações na comunicação entre desenvolvedores e especialistas do domínio. Até mesmo entre os próprios desenvolvedores pode haver confusão, pois cada um pode criar um entendimento diferente sobre o domínio em sua cabeça.

Para fortalecer a comunicação dos envolvidos em um projeto de software e garantir a precisão do modelo, Evans defende extensivamente ao longo do livro a utilização de uma \emph{linguagem onipresente}. Essa linguagem onipresente deve ser utilizada na comunicação oral e escrita do time, além de ser utilizada nos diagramas, código-fonte etc. Assim, a \lgg faz a ligação entre a comunicação do time e a implementação do software.

Lacunas na linguagem onipresente evidenciam a falta de um conceito no modelo. Palavras estranhas podem evidenciar imprecisões do modelo ou divergências entre a implementação e os objetivos do negócio. Mudanças na linguagem onipresente são mudanças no modelo. Assim ela deve ser mantida e zelada por todo o time. Especialistas do domínio devem impedir a existência de termos inapropriados para o domínio, enquanto que desenvolvedores devem impedir ambiguidades e inconsistências.

Na comunicação diária, tanto especialistas quanto desenvolvedores ainda utilizarão termos fora da linguagem onipresente. Esses termos podem ser termos técnicos ligados à implementação do software ou conceitos mais avançados do negócio, não necessários à implementação do software. Tais termos devem ser complementares à linguagem onipresente, e não conflitantes com a linguagem onipresente.

Embora seja rápido e fácil falar sobre a \lgg, ela é uma ideia central ao longo do livro. Em praticamente todos os capítulos o autor aproveita para reforçar o assunto, aplicando-o nos mais diferentes contextos, seja na produção de código, seja na conversa com os especialistas.


\section{Camadas de um software}

O primeiro passo para um design dirigido pelo domínio é o isolamento da lógica do negócio de outras características que o software deve implementar. Isso é feito com a separação do software em camadas. Assim temos uma camada do domínio que fica desacoplada do restante do sistema. Isso facilita a manutenção, pois podemos criar designs mais coesivos e identificar rapidamente os pontos de mudança no software. Além disso, o isolamento das regras de negócio potencializa o reuso de código, pois a mesma regra de negócio pode ser reaproveitada em um aplicativo móvel ou por um web service, por exemplo.

As camadas podem ser classificadas em interface, aplicativo, domínio e infra.

\begin{description}
\item [Interface:] interage com o usuário, coletando entradas e exibindo saídas. Esse usuário pode ser tanto uma pessoa quanto outro sistema.
\item [Aplicativo:] implementa as funcionalidades disponíveis para o usuário. Essa camada tende a ser bem magra e apenas dirige a camada de domínio para que a funcionalidade seja entregue.
\item [Domínio:] é o coração do sistema, onde estão os conceitos, regras e estado do negócio. É a parte do sistema onde menos os \emph{frameworks} e plataformas podem ajudar. É onde mais a criatividade e as capacidades de análise e design se fazem necessárias. E é nessa camada que o livro Domain-Driven Design é focado.
\item [Infra:] recursos técnicos como persistência, troca de mensagens etc. É aqui que ficam os chamados DAOs (Data Access Objects), que fazem o mapeamento entre objetos e registros de um banco de dados.
\end{description}

\citacao{O princípio essencial é de que qualquer elemento de uma camada depende somente dos outros elementos da mesma camada ou dos elementos das camadas ``abaixo'' dela. A comunicação para cima deve passar por algum tipo de mecanismo indireto}. Ou seja, o importante aqui é que a camada de domínio seja auto-contida e não dependa de nenhuma das outras camadas do software.

A aplicação do princípio da inversão de dependência para possibilitar que a camada de domínio não dependa de outras camadas é descrito nesses dois posts do Uncle Bob: ``The Clean Architecture''\footnote{https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html} e ``A Little Architecture''\footnote{http://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html}. A ideia básica é que a interface do DAO pertence à camada do domínio, enquanto que é a implementação do DAO que pertence à camada de infra. Citando um trechinho: \citacao{A web é um detalhe. O banco é um detalhe. Nós deixamos essas coisas do lado de fora, onde elas não podem trazer muito dano.}

Normalmente a infraestrutura é exaltada como o ponto principal na definição da arquitetura de um software. Alguns acham que a escolha do Sistema Gerenciador de Bancos de Dados é a mais importante. Algumas outras se degladiam pela escolha do \emph{framework} de desenvolvimento. Mas o post ``A Little Architecture'' esclarece como essas coisas na realidade importam muto pouco. As regras de negócio tendem a ser mais duradouras que as tecnologias empregadas. E queremos ser capazes de facilmente substitui tecnologias obsoletas se preciso. Entendemos que as regras de negócio são a parte mais valiosa do sistema. Por isso a importância do estudo do DDD, que consiste no aprimoramento de nossa capacidade em escrever a camada do domínio.


\section{Elementos do domínio}

Os elementos do domínio classificados por Evans são: entidades, objetos de valor e serviços.

\begin{description}

\item [Entidades] representam algo com identidade e com uma continuidade rastreável por diferentes estados e até diferentes implementações. A definição de um objeto como esse não está em seus valores, pois objetos diferentes com valores iguais ainda devem ser distinguíveis. A definição da identidade é a principal característica de uma entidade. Um exemplo de entidade é um veículo que deve ser identificável em diferentes partes do sistema como correspondente a um determinado veículo único existente no mundo real. Dois veículos Fox, da Volkswagen, ambos de cor preta e demais características de fábrica idênticas ainda são veículos distintos.

\item [Objetos de valor] descrevem o estado de alguma coisa. Por exemplo, um veículo pode ter uma cor, que é descrita por uma combinação numérica RGB. Dois veículos podem ter cores idênticas, mas não precisamos nos preocupar com que os dois objetos veículos apontem exatamente para o mesmo objeto cor. Ou seja, nesse caso a cor não possui uma identidade. Ela é meramente um valor. Para reforçar: enquanto uma entidade define \emph{quem} ela é, um objeto de valor define \emph{o que} ele é. Objetos de valor devem ser imutáveis. Assim, um veículo pode mudar de cor, mas não é a cor do veículo que se altera. Ou seja, o objeto veículo passa a apontar para um novo objeto cor e o antigo objeto cor é esquecido. A imutabilidade traz várias vantagens ao design de software~\cite{Bloch2008Mutability}, e podemos aproveitar essas vantagens nos objetos de valor.

\item [Serviços] são operações oferecidas como interfaces, isoladas no modelo e que não possuem estado. Acomodam operações que possuem significado no domínio, mas que não se encaixam em entidades ou objetos de valor. Serviços devem ser criados com parcimônia, pois a utilização de serviços deixa o software menos orientado a objeto e mais procedural. Mas às vezes são convenientes para que regras complicadas de orquestração dos elementos do domínio não vazem para a camada de aplicação. Um exemplo seria a transferência de dinheiro entre contas bancárias caso a operação \code{transferência} não se encaixe adequadamente no objeto \code{conta}. Serviços existem em todas as camadas do software. Um exemplo de serviço de infra é o envio de e-mail. Mas é preciso ter os serviços de cada camada bem caracterizados e separados.

\item [Módulos,] chamados de pacotes na linguagem Java, são agrupamentos de classes. Devem possuir significado no domínio. A hierarquia de módulos deve refletir uma hierarquia do domínio. O nome de um módulo deve ser expressivo e pertencer à linguagem onipresente. A coesão e acoplamento dos módulos também deve ser controlada. A separação dos módulos deve isolar conceitos para facilitar o entendimento dos mesmos. A refatoração da estrutura de módulos é mais complicada do que a refatoração de classes, mas não menos importante.

\end{description}

\section{Entidades e suas regras de negócio}

Uma prática adotada por muitos desenvolvedores é a separação entre dados e comportamentos de uma entidade em objetos separados. Em algumas nomenclaturas seriam as \emph{entities} e os \emph{BCs} (\emph{business classes}). A página 107 do livro inicia uma discussão importante ao criticar essa separação. Quando possível, deixe o comportamento de uma entidade no mesmo objeto que define seus dados. Assim, Evans sugere que as regras de negócio que ficam isoladas nos BCs passem a integrar as entidades. Além disso, regras do BC que sejam na verdade regras que manipulem o ciclo de vida da entidade (criação, alteração e deleção) podem se acomodar melhor em fábricas ou repositórios (ver próxima seção).

Essa separação de entidade com dados de um lado e BCs com regras de negócio do outro gera o que é chamado por aí de modelo anêmico. Alguns textos de rápida leitura que corroboram com o desencorajamento do modelo anêmico:  ``AnemicDomainModel''\footnote{\url{http://www.martinfowler.com/bliki/AnemicDomainModel.html}} e ``O que é Modelo Anêmico? E por que fugir dele?''\footnote{\url{http://blog.caelum.com.br/o-que-e-modelo-anemico-e-por-que-fugir-dele/}}.

Mas a adoção dessa prática deve possuir alguns cuidados, como não criar acoplamentos indesejados. Exemplo: \code{empresa.possuiFuncionarioProcessado()} parece uma interessante adesão a um modelo não anêmico. Mas se a princípio o modelo não exige que o objeto ``empresa'' tenha conhecimento de objetos de ``processos'', esse método pode não ser uma boa ideia. Nesse caso, melhor talvez seria algo como \code{processoRepositorio. possuiFuncionarioProcessado(empresa)}.

Contudo, ainda há controvérsias... No livro Clean Code, Uncle Bob faz uma distinção entre objetos e estruturas de dados~\cite{Bob2008DataStructures}. Ele considera que no padrão \emph{active record}\footnote{\url{https://pt.wikipedia.org/wiki/Active_record}}, os modelos (classes que fazem a ponte com o banco de dados para a persistência das entidades) devem ser simples estruturas de dados. Ele critica a colocação de regras de negócio nessas estruturas de dados e termina concluindo que \citacao{a solução é, claro, tratar o Active Record como uma estrutura de dados e criar objetos separados que contenham as regras de negócio e que escondam seus dados (que são provavelmente apenas instâncias do Active Record)}. Alguns trechos a mais desse capítulo do Clean Code podem ser encontrados no post ``Clean Code: objetos não são estruturas de dados!''\footnote{\url{http://polignu.org/artigo/clean-code-objetos-n\%C3\%A3o-s\%C3\%A3o-estruturas-de-dados}} 

Essa solução no fundo vai de encontro à recomendação da OO sobre não expor publicamente todos os dados de uma entidade. Mas forçar essa separação da entidade em classes diferentes parece um tanto burocrático e cair no caso criticado por Evans, no qual há uma separação da entidade conceitual em diferentes objetos, sendo um para manter a estrutura de dados e o outro para as regras de negócio da entidade.

Para concluir a controvérsia, minha posição neste momento é de que a postura mais equilibrada parece ser implementar suas entidades como classes contendo os dados da entidade nos atributos e as regras de negócio em métodos públicos, mas evitando a publicização desnecessária dos dados da entidade. Em Java isso seria não criar \emph{getters} e \emph{setters} desnecessariamente. Uma posição similar pode ser depreendida do post ``Como não aprender Java e Orientação a Objetos: getters e setters''\footnote{\url{http://blog.caelum.com.br/nao-aprender-oo-getters-e-setters/}}. Já para Python utilizando Active Record, ainda não estou tão certo, uma vez que a questão da visibilidade dos atributos do objeto é bem mais sutil. 

Essa é uma discussão pra lá de complicada! Caso você tenha sua opinião, eu ficaria feliz em ouvi-la.

\section{Padrões do ciclo de vida de um objeto do domínio}

Nesta seção apresentamos os padrões que auxiliam no controle do ciclo de vida de objetos: como eles nascem, são persistidos, recuperados, excluídos e como a integridade dos objetos e de seus relacionamentos é mantida.


\begin{description}

\item [Agregados] possuem uma entidade raiz e vários objetos de valor. Um exemplo é uma entidade carro que possui quatro objetos pneus. Embora os pneus sejam objetos separados, o conjunto do carro mais os quatro objetos pneus formam uma unidade coesa que sempre permanece junta, à o que chamamos de agregado. Como no exemplo os pneus não tem razão de ser fora do carro, esses pneus podem ser meros objetos de valor. Membros externos ao agregado acessam somente a entidade raiz e não podem modificar diretamente os objetos de valor. Assim, a entidade raiz garante as invariantes do grupo. No nosso exemplo, uma invariante do agregado a ser observada é a existência de exatamente quatro pneus. Outro exemplo de agregado: uma empresa pode ser uma entidade. Mas para a completa descrição da empresa podemos necessitar de um objeto endereço, que seria um objeto de valor fazendo parte do agregado da empresa.

\item [Fábricas] encapsulam processos complexos de criação de objetos a partir de um conjunto de dados. A fábrica não cuida de persistência. A fábrica pode instanciar um novo objeto ou reconstituir um objeto já existente a partir de seu formato serializado. É comum que a fábrica crie todo um agregado completo.
Existem diversos padrões de projetos sobre como criar fábricas. O padrão \emph{builder} é um exemplo bem legal~\cite{Bloch2008Builder}. Algumas vantagens da utilização de fábricas podem ser encontradas no livro Effective Java~\cite{Bloch2008Factory}. 

\item [Repositórios] oferecem a abstração de coleção de um conjunto de objetos ou agregados do mesmo tipo. Assim, clientes\footnote{Quando um objeto A utiliza outro objeto B, dizemos que o objeto A é o \emph{cliente} dessa relação.} podem inserir, editar, excluir e consultar objetos de uma determinada coleção. Repositórios devem ser construídos apenas para as raízes dos agregados. As consultas podem ser feitas na medida para evitar o vazamento de encapsulamento de detalhes para o cliente, o que seria mais propenso a acontecer caso o cliente acessasse diretamente o banco de dados (via DAO). Condições de negócio para a inserção/alteração/exclusão do objeto devem ser garantidas pelo repositório. A implementação do repositório é uma implementação de negócio, não devendo se acoplar com a tecnologia de persistência (ex: banco de dados). Por isso, em última instância, o repositório delega uma tarefa ao DAO. Exemplo: uma empresa com alguma irregularidade não pode ser inserida na coleção de empresas participantes de uma licitação. Essa é uma regra do repositório, e não do DAO. O DAO deve se preocupar somente com a tecnologia da infraestrutura.

\end{description}

Utilizando os padrões apresentados, eis um cenário típico de criação de um novo objeto:

\begin{enumerate}
\item Cliente pede à fábrica para criar um objeto.
\item Cliente recebe o objeto criado pela fábrica.
\item Cliente pede ao repositório para salvar objeto criado.
\item Repositório pede ao DAO para persistir dados do objeto no banco de dados.
\end{enumerate}

Já para a recuperação de um objeto podemos ter:

\begin{enumerate}
\item Cliente pede o objeto ao repositório.
\item Repositório acessa o banco via DAO para obter dados persistidos do objeto.
\item Repositório repassa dados persistidos do objeto à fábrica.
\item Fábrica reconstrói o objeto, que é devolvido ao repositório, que é devolvido ao cliente.
\end{enumerate}

A complexidade desses passos vale a pena no caso mais complicado, no qual a reconstituição do objeto não se resume simplesmente em restaurar os dados persistidos no banco. O que o banco guarda pode ser apenas parte do que o objeto é em tempo de execução. Esse é um dos motivos pelo qual é muito arriscado permitir que um sistema tenha acesso direto ao banco de dados de outro sistema. Impor restrições no modelo de dados do banco pode nos dar algumas garantias. Porém, essas regras no banco podem não ser suficientes para manter complexas restrições semânticas decorrentes de regras do domínio.

O DAO é o objeto focado na tecnologia de banco de dados, mas isso é um aspecto apenas de sua implementação. A interface do DAO não deve conter detalhes da tecnologia. Tudo o que o domínio sabe é que o objeto está sendo persistido em algum lugar. O domínio permanece totalmente ignorante quanto a tecnologia utilizada. Ou seja, a interface do DAO deve ser definida do ponto de vista do negócio. Lembre-se: o domínio não deve depender de detalhes (o banco é um detalhe). São são os detalhes (DAOs) que devem depender do domínio. Idealmente temos então a interface do DAO sendo definida dentro do domínio e sua implementação na camada de infra. Em Java podemos separar esses dois artefatos (interface e implementação) nessas diferentes camadas. Mas como na maioria dos casos o DAO sempre vai ter uma única implementação, uma abordagem mais pragmática é fazer uma única classe DAO na camada de infra, sem o artefato de interface. Contudo, as assinaturas dos métodos e o nome do DAO continuam sendo sua interface, e essa interface continua devendo ser definida em termos do domínio.


\section{Evolução do modelo do domínio}

O modelo do domínio não nasce pronto. Conforme os desenvolvedores avançam na implementação, eles aprendem e assimilam muito conhecimento sobre o domínio. E esse conhecimento deve ser utilizado para incrementar o domínio. Assim, Evans defende constantemente a refatoração contínua do software. Não só a refatoração técnica que melhora o design das classes, mas a refatoração para que o modelo melhor expresse conceitos e soluções no domínio.

Por vezes os desenvolvedores podem notar indícios de que o modelo deve ser refinado. Algumas situações: pessoas diferentes utilizam nomes diferentes para a mesma coisa (talvez conceitos devam ser uniformizados); a descrição de algum relacionamento é muito complicada (talvez esteja faltando um novo conceito); novos conceitos que surgem não se encaixam com um dos conceitos já estabelecidos (talvez algum conceito velho deva ser descartado); percebe-se que o design não expressa o entendimento atual da equipe sobre o domínio (conceitos do software não coincidem com os conceitos mentais das pessoas).

Um bom momento para detectar refinamentos necessários ao modelo é durante sessões de discussão entre desenvolvedores e pessoas do negócio quando ambos podem interagir por meio de diagramas rabiscados em uma lousa. Nesse sentido, Evans valoriza bastante a utilização de diagramas informais. O ponto central sobre diagramas é comunicação. A UML é um bom ponto de partida, mas se prender às suas regras restritas traz mais prejuízo que benefício. Eu particularmente me aborreço com ferramentas que restringem como você pode desenhar seus diagramas só para não desrespeitar a UML.

Pequenas evoluções incrementais são as vezes interrompidas por uma \emph{oportunidade de avanço}, que leva a um \emph{modelo mais profundo} por meio de alterações abruptas que se propagam por várias partes do sistema. Embora esse tipo de refatoração seja complicada, um modelo mais profundo pode trazer vantagens ao aumentar sua versatilidade e seu poder explicativo. 

Um modelo mais profundo consegue resolver situações particulares com regras gerais. Um sistema com muito código dedicado a casos particulares é um sinal de que o modelo não tem força suficiente. Um modelo bem desenvolvido oferece ao software a propriedade da \emph{emergência}. A emergência significa que comportamentos complexos benéficos emergem (de forma não antecipada) a partir de regras simples contidas nas unidades do sistema~\cite{37signals2006GettingReal}. A busca por conceitos elegantes que evitem a utilização de regras complicadas é um dos benefícios esperados das oportunidades de avanço. Porém, uma oportunidade de avanço não é algo planejado, mas um evento que ocorre de tempos em tempos. E é preciso estar atento para quando o momento chegar.

Mas antes de arregaçar as mangas e se aventurar em alterações radicais de seu design, mais um conselho. Após uma discussão sobre uma oportunidade de avanço, espere alguns dias e discuta novamente a proposta. Esse tempo ajuda a deixar a ideia mais madura e dar confiança ao time de que esse é o melhor caminho. ``Dormir com o problema'' ajuda.


\section{Dicas de design}

\begin{itemize}

\item Cada caso é um caso. O próprio autor em diversos momentos toma uma postura bem pragmática, incentivando que a equipe tome as decisões considerando o contexto e ponderando os compromissos.

\item Associações bidirecionais e referências circulares são problemáticas para o design. Ás vezes são necessárias, mas tente evitá-las.

\item A direção da associação muitas vezes capta uma visão aprofundada do domínio. Exemplo: é o veículo que possui as rodas, e não o contrário.

\item Explicite os conceitos implícitos.

\item É preciso muita interação e conversa com os especialistas do domínio. Rabiscar diagramas no quadro branco ajuda bastante. 

\item Acertar o design de primeira não existe.

\item Ler livros sobre o domínio também pode ajudar.

\item Outros conceitos além de substantivos e verbos (classes e métodos) podem fazer parte do modelo: restrições, processos de negócios e especificações.

\item Objetos e agregados devem manter invariantes, que são \emph{restrições} sobre seus atributos. Explicite as restrições extraindo a lógica de restrição para um método dedicado a isso. Há também casos para extrair a restrição para uma nova classe: se a lógica de restrição é muito complexa; se a lógica de restrição apresente dependências estranhas ao objeto original; se a mesma restrição aparece em classes diferentes. Um exemplo de restrição modelada em uma classe especializada é uma \code{política de overbooking}, que é utilizada para manter uma restrição entre as associações de um objeto de \code{viagem} para vários objetos de \code{carga} considerando os atributos \code{viagem.capacidade} e \code{carga.tamanho}.

\item Serviços do domínio podem encapsular procedimentos que façam sentido do ponto de vista do negócio. Além disso, existem \emph{processos} mais complexos, no qual uma determinada entidade passa por etapas de um longo processo para atingir um objetivo. Um exemplo comum é a emissão de documentos, que exige etapas como fornecimento de dados, pagamento e coleta do documento. Nesses casos, modelos baseados em máquinas de estado são úteis. Um padrão de projeto que pode ajudar é o \emph{state}~\cite{Freeman2004Patterns}.

\item \emph{Especificações} utilizam regras complexas para avaliar um objeto e retornam um booleano. Com regras simples poderíamos determinar se uma \code{fatura} está vencida com o método \code{fatura.vencida()}. Mas caso estas regras se tornem muito complexas ou criem dependências estranhas à classe \code{Fatura}, podemos extrair a lógica de avaliação do vencimento para uma nova classe. Para avaliar o vencimento da fatura teríamos então \code{especificacaoDeFatura.estaVencida(fatura)}, sendo que é \code{EspecificacaoDeFatura} que depende de \code{Fatura}, e não ao contrário. A especificação é um mero objeto de valor que é criado e utilizado quando necessário, sendo logo depois descartado.

\item Para obter uma coleção de objetos que respeite uma determinada especificação, a princípio seria interessante desacoplar a especificação do repositório. Mas está aí um caso no qual o desempenho pode ser um fator decisivo para que o repositório conheça as regras da especificação, de forma a termos uma consulta no banco que já recupera somente os objetos de interesse.

\item Quando aplicável, utilize \emph{asserções} para garantir o estado do objeto após determinada operação. Na prática, essas asserções são implementadas nos testes de unidade.

\item Use \emph{interfaces reveladoras de intenções} para diminuir esforço cognitivo do desenvolvedor. Para utilizar um objeto não deve ser necessário entender sua implementação, mas apenas sua interface. Utilizar bons nomes é o caminho para isso. Desenvolvimento orientado por testes (TDD) também ajuda a definir interfaces mais claras e focadas no cliente.

\item \emph{Funções} devolvem valores, enquanto \emph{comandos} têm efeitos colaterais. Um método deve ser ou uma função ou um comando. Não misture os dois. Prefira funções. Comandos devem ser bem simples. Cálculos complexos ficam melhor em objetos de valor em vez de entidades.

\item Se possível, crie funções \emph{fechadas} sobre elas mesmas. Ou seja, a função retorna um objeto do mesmo tipo que o objeto que contém a função. Exemplo: \code{x.inverse()} retorna um número real a partir de outro número real. Se o retorno for do mesmo tipo que o argumento da função também já ajuda. Exemplo: \code{Math.inverse(x)}.

\item Se esforce para reduzir as dependência entre classes e módulos (diminuir o acoplamento). Se possível, crie classes autônomas, que podem ser estudadas por si só. Isso diminui o esforço cognitivo em compreender/usar/testar os elementos do domínio. Dependências na interface são piores que dependências internas; dependências com elementos fora do módulo são piores que dependência com elementos dentro do módulo.

\item Evans vê com certa reserva abordagens como design declarativos, sistemas baseados em regras e linguagens declarativas. São interessantes, mas há limitações. O autor encoraja a utilização dos padrões apresentados ao longo do capítulo para que o próprio código orientado a objetos tenha um estilo mais declarativo. 

\item Uma disputa similar sobre paradigmas exóticos ocorre sobre a utilização de linguagem natural para a especificação de testes de software. Alguns autores defendem a utilização da própria linguagem de propósito geral (ex: Java) com sentenças cuidadosamente criadas em um estilo mais declarativo para expressar os requisitos do software em testes automatizados~\cite{Freeman2009Tests}.

\item Especificações combinadas com operadores lógicos podem dar um estilo declarativo ao código. Sendo \emph{Spec} uma especificação de um contêiner de transporte, podemos ter: \code{Spec ambos = ventilado.and(blindado)}, sendo os objetos envolvidos do tipo \code{Spec}. Podemos também testar se \code{umaSpec.inclui(outraSpec)}. 

\item Um estilo declarativo bem popular hoje em dia é a chamada \emph{interface fluente}\footnote{\url{http://martinfowler.com/bliki/FluentInterface.html}}. Podemos encontrar um exemplo na biblioteca Mockito, utilizada para a criação de mocks em testes de unidade: \code{when(object.do()).thenReturn(someThing)}. O próprio padrão \emph{builder} é também um exemplo de interface fluente.

\item Lembre-se: softwares não são somente para usuários. Eles também são para desenvolvedores, que devem manter o código.


\end{itemize}

\section{Modelando sistemas de grande escala}

Os capítulos finais do livro \ddd são voltados para a modelagem de grandes sistemas, que envolvem integrações diversas. As discussões apresentadas nesta seção podem não se aplicar a sistemas mais simples, mas tratam de uma realidade comum em grandes empresas. Não só para esse conteúdo, mas para qualquer recomendação de design, saiba avaliar o que se aplica à sua situação específica.

A unificação total do modelo do domínio para um sistema grande pode não ser factível ou econômica. Divide-se assim o modelo em \emph{contextos delimitados}. Um contexto delimitado é algo maior que os módulos, correspondendo normalmente a sub-sistemas ou até a sistemas diferentes que possuem alguma relação entre si. A visão global da relação entre esses contextos delimitados é o \emph{mapa do contexto}. Os nomes presentes no mapa do contexto devem fazer parte da linguagem onipresente. Essa delimitação entre contextos nos ajuda a evitar problemas como conceitos duplicados e falsos cognatos. A separação entre contextos pode ter relação com a divisão de trabalho entre equipes. 

Há várias abordagens para tratar a passagem conceitos de um contexto para outro contexto. Essa passagem pode requerer a \emph{tradução} de conceitos. Pode-se evitar a passagem de conceitos por meio da criação de um \emph{núcleo compartilhado}, que é um contexto compartilhado por diferentes sub-sistemas. Muitas vezes o núcleo compartilhado corresponde ao \emph{domínio principal} da aplicação.

Um caso comum é que dois contextos delimitados tenham a relação de cliente/fornecedor, na qual o fluxo de controle flui em apenas um sentido entre os contextos. O cliente pode adotar uma abordagem \emph{conformista}, aceitando um contexto imposto pelo fornecedor sem o isolamento de uma camada de tradução. Caso opte-se pela tradução, mas o contexto fornecedor seja muito complicado e até mal desenhado, o contexto cliente pode tomar uma atitude defensiva utilizando uma \emph{camada anticorrupção} para que o modelo do cliente mantenha-se limpo. A camada anticorrupção normalmente é implementada como um conjunto de serviços. Padrões de projetos usados na camada anticorrupção são a \emph{fachada} e \emph{adaptadores}. 

O fornecedor pode expor uma \emph{linguagem publicada}, que é um contexto desenhado especialmente para ser utilizado por outros sistemas. Esse é o caso da exposição de APIs REST ou Web Services, bastante utilizados hoje em dia.

Mas a integração entre sistemas é sempre cara, e por isso as vezes é melhor manter \emph{caminhos separados} e duplicar um pouco de código para manter as coisas simples e até facilitar a evolução de sistemas que, apesar de alguma semelhança, são independentes.

Subdomínios coesos que não são centrais para seu domínio principal e que podem servir de apoio para outros domínios podem ser segregados em \emph{subdomínios genéricos}. Exemplo: princípios gerais de contabilidade, conversão de fuso-horários, etc. Não se preocupe antecipadamente com a reutilização do subdomínio genérico por outro sistema. Faça o mínimo possível para resolver o seu problema. Mantenha o domínio segregado sem dependências para seu domínio principal. Subdomínios genéricos ajudam a diminuir a sobrecarga no domínio principal. Ou seja, fica mais simples de entender o domínio principal. Subdomínios genéricos podem também ter sua implementação terceirizada mais facilmente do que partes do domínios principal.

Seja qual for a estratégia para gerenciar múltiplos contextos delimitados, a \emph{integração contínua} ajuda a manter a harmonia entre os diferentes contextos. Testes automatizados executados continuamente em um ambiente neutro fortalecem a garantia de consistência entre os contextos. Assim, a integração contínua funciona como uma forma de comunicação eficiente para alertar caso alterações que uma equipe faça em um contexto tenham impactos negativos em algum contexto mantido por outra equipe.

Pode-se também melhor organizar um contexto dividindo-o em \emph{camadas}. A camada A utiliza a camada B, enquanto que a camada B nem conhece a camada A. O livro fornece um exemplo genérico de divisão em camadas que pode ser adotado em diferentes sistemas. A camada de \emph{potencial} define políticas e especificações, que são as coisas como elas deveriam ser. Exemplo: especificação da rota de um navio cargueiro. A camada de \emph{operações} corresponde ao estado das coisas como elas realmente estão. Exemplo: a rota já definida para um navio cargueiro. E a camada de \emph{apoio a decisões} possui algoritmos inteligentes que usam como insumo as camadas de potencial e de operações. Exemplo: geração de relatórios sobre custos baseados nas rotas de uma frota de cargueiros.

Embora o uso comum do padrão de camadas seja dividir um único contexto em camadas, as camadas podem ser usadas de forma mais flexível. É possível que uma camada atravesse contextos delimitados. Pode ser que as camadas forneçam uma visão de super alto nível que organize o mapa de contexto. No livro temos um exemplo de transporte de carga com os contextos ``reservas'' e ``rede de transporte'' dentro da camada de operações e o contexto ``programação de transporte'' dentro da camada potencial.

O autor enfatiza que a estrutura em grande escala também deve evoluir conforme o entendimento sobre o domínio é refinado. A refatoração do modelo de grande escala é bem mais complicada, mas o autor julga ser um investimento necessário para que o modelo possa continuar evoluindo de forma saudável.

\section{Conclusão}

O desenvolvimento de software deve utilizar uma abordagem voltada para sistemas complexos. Ou seja, componentes fracamente acoplados interagem para que um comportamento alinhado com os objetivos do negócio possa emergir. O estudo do DDD nos orienta na modelagem do software seguindo a mentalidade de sistemas complexos, desacoplando partes do domínio e desacoplando o próprio domínio de outros detalhes do sistema. 

Quando se fala em arquitetura de software, muitos logo pensam na topologia de máquinas servidores, sistema de virtualização, servidores http e de aplicação, \emph{frameworks} e nas conexões com o banco de dados. Tudo isso faz parte da arquitetura do sistema. Mas também faz parte da arquitetura o \emph{modelo do domínio} e sua organização. Essa modelagem requer um profundo entendimento do domínio. Por isso, o conhecimento de negócio assimilado pelos desenvolvedores deve ser valorizado.

É comum que desenvolvedores mais talentosos sejam atraídos para o desenho da arquitetura de infraestrutura ou utilização de \emph{frameworks}. Essas áreas costumam empolgar os desenvolvedores pois são áreas que apresentam oportunidades para a utilização de novas tecnologias. No entanto, transformar  um domínio complexo em um design de software compreensível e útil é uma atividade complexa e extremamente desafiante. Por isso, a capacitação na modelagem e implementação do domínio merece toda a atenção durante o desenvolvimento de um sistema. Afinal, é o modelo do domínio o verdadeiro coração do software, aquilo que dá valor ao sistema e o torna único.

\small

\bibliographystyle{apalike}
\bibliography{referencias}  


\end{document}
